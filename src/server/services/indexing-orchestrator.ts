import { db } from "~/server/db";
import { contentText, contentChunks } from "~/server/db/schema";
import { indexingConfig } from "~/server/config/indexing-config";
import { fetchContent, ContentFetchError } from "./content-fetcher";
import { chunkContent } from "./content-chunker";
import { eq } from "drizzle-orm";
import crypto from "crypto";

export interface IndexingResult {
  success: boolean;
  contentItemId: string;
  error?: string;
}

export interface IndexingStats {
  total: number;
  succeeded: number;
  failed: number;
  results: IndexingResult[];
}

/**
 * Calculate SHA256 hash of text
 */
function calculateHash(text: string): string {
  return crypto.createHash("sha256").update(text).digest("hex");
}

/**
 * Index a single content item
 * Fetches content, chunks it, stores in database
 */
async function indexSingleItem(
  contentItemId: string,
  url: string,
): Promise<IndexingResult> {
  try {
    // Step 1: Fetch content
    const fetchResult = await fetchContent(url);

    // Handle empty content (e.g., no YouTube transcript)
    if (!fetchResult.plainText) {
      return {
        success: false,
        contentItemId,
        error: "No content available (empty or transcript unavailable)",
      };
    }

    const contentHash = calculateHash(fetchResult.plainText);

    // Step 2: Store full content
    const [contentTextRecord] = await db
      .insert(contentText)
      .values({
        contentItemId,
        fullText: fetchResult.fullText,
        plainText: fetchResult.plainText,
        wordCount: fetchResult.wordCount,
        tokenCount: fetchResult.tokenCount,
        contentHash,
        crawlDurationMs: fetchResult.duration,
        indexStatus: "pending",
      })
      .returning();

    if (!contentTextRecord) {
      throw new Error("Failed to insert content_text record");
    }

    // Step 3: Chunk content
    const chunks = await chunkContent(fetchResult.plainText);

    // Step 4: Store chunks (embeddings generated by pgai)
    await db.insert(contentChunks).values(
      chunks.map((chunk) => ({
        contentTextId: contentTextRecord.id,
        chunkText: chunk.text,
        chunkIndex: chunk.index,
        chunkTokenCount: chunk.tokenCount,
      })),
    );

    // Step 5: Mark as indexed
    await db
      .update(contentText)
      .set({
        indexStatus: "indexed",
        indexedAt: new Date(),
      })
      .where(eq(contentText.id, contentTextRecord.id));

    return {
      success: true,
      contentItemId,
    };
  } catch (error) {
    // Store error in database
    try {
      const existing = await db.query.contentText.findFirst({
        where: eq(contentText.contentItemId, contentItemId),
      });

      if (existing) {
        await db
          .update(contentText)
          .set({
            indexStatus: "failed",
            indexError:
              error instanceof ContentFetchError
                ? error.message
                : error instanceof Error
                  ? error.message
                  : "Unknown error",
          })
          .where(eq(contentText.id, existing.id));
      }
    } catch (dbError) {
      console.error("Failed to update error status:", dbError);
    }

    return {
      success: false,
      contentItemId,
      error:
        error instanceof ContentFetchError
          ? error.message
          : error instanceof Error
            ? error.message
            : "Unknown error",
    };
  }
}
